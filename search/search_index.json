{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"decorative-secrets","text":"<p>This library implements decorators for mapping parameters passing sensitive data, such as authentication credentials, to alternate parameters indicating where the same credentials can be retrieved dynamically from a secrets manager and/or environment variables. The use of a decorator pattern to expose multiple authentication mechanisms is intended to facilitate development practices which maintain a semblance of harmony between security hygiene and test-driven development.</p> <p>Currently, the following secret sources are supported:</p> <ul> <li>Databricks Secrets     (<code>pip3 install decorative-secrets[databricks]</code>)</li> <li>1Password     (<code>pip3 install decorative-secrets[onepassword]</code>):     1Password secrets are retrieved dynamically using the 1Password CLI          under the hood. This mechanism can be used with the 1Password desktop     client and CLI, in which case a popup window will prompt for authentication     during execution, or can use a 1Password service account      by setting     the <code>OP_SERVICE_ACCOUNT_TOKEN</code> environment variable. The former is     recommended for local development and testing, the latter for CI/CD and/or     hosted applications.</li> <li>Environment Variables</li> </ul> <p>Future development should target support for AWS Secrets Manager, Google Cloud Secret Manager, and Azure Key Vault (minimally).</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>decorative-secrets</code> with pip:</p> <pre><code>pip3 install decorative-secrets\n</code></pre>"},{"location":"#example-usage","title":"Example Usage","text":"<pre><code>from functools import cache\nfrom my_app_sdk.client import Client\nfrom decorative_secrets.environment import apply_environment_arguments\nfrom decorative_secrets.onepassword import apply_onepassword_arguments\nfrom decorative_secrets.databricks import apply_databricks_secrets_arguments\n\n@cache\n@apply_environment_arguments(\n  client_id=\"client_id_environment_variable\",\n  client_secret=\"client_secret_environment_variable\",\n)\n@apply_databricks_secrets_arguments(\n  client_id=\"client_id_databricks_secret\",\n  client_secret=\"client_secret_databricks_secret\",\n)\n@apply_onepassword_arguments(\n  client_id=\"client_id_onepassword\",\n  client_secret=\"client_secret_onepassword\",\n)\ndef get_client(\n    client_id: str | None = None,\n    client_secret: str = None,\n    client_id_databricks_secret: tuple[str, str] | None = None,\n    client_secret_databricks_secret: tuple[str, str] | None = None,\n    client_id_onepassword: str | None = None,\n    client_secret_onepassword: str | None = None,\n    client_id_environment_variable: str | None = None,\n    client_secret_environment_variable: str | None = None,\n) -&gt; Client:\n    \"\"\"\n    This function is an example use of `decorative-secrets`.\n    The returned client will authenticate with explicitly provided\n    credentials if a `client_id` and `client_secret` are passed as arguments,\n    otherwise, the same function call will first check to see if\n    environment variables can be used, then will check to see if databricks\n    secrets can be used, and lastly will check to see if 1password\n    stored credentials can be obtained. In all cases where\n    an argument other than `None` is passed, errors will be caught and\n    accumulated for that parameter, but only raised if none of the\n    successive mechanisms for retrieving a value for the parameter are\n    successful.\n\n    Parameters:\n        client_id: An eplicitly passed OAuth 2 client ID\n        client_secret: An explicitly passed OAuth 2 client secret\n        client_id_databricks_secret: A databricks secrets scope and key\n        from which to retrieve the client ID, if executed in a Databricks\n        Runtime environment\n        client_secret_databricks_secret: A databricks secrets scope and key\n        from which to retrieve the client secret, if executed in a Databricks\n        Runtime environment\n        client_id_onepassword: A onepassword reference from which to retrieve\n        the client ID. Note: the user will be prompted to login, if they have\n        not already done so, unless a `OP_SERVICE_ACCOUNT_TOKEN` environment\n        variable has been set, and/or both both an `OP_CONNECT_HOST` and\n        `OP_CONNECT_TOKEN` environment variable have been set.\n        client_secret_onepassword: A onepassword reference from which to retrieve\n        the client secret. Note: the user will be prompted to login, if they have\n        not already done so, unless a `OP_SERVICE_ACCOUNT_TOKEN` environment\n        variable has been set, and/or both both an `OP_CONNECT_HOST` and\n        `OP_CONNECT_TOKEN` environment variable have been set.\n        client_id_environment_variable: An environment variable from which\n        the client ID may be retrieved\n        client_secret_environment_variable: An environment variable from which\n        the client secret may be retrieved\n    \"\"\"\n    return Client(\n        oauth2_client_id=client_id,\n        oauth2_client_secret=client_secret\n    )\n\n\n# Initialize an OAuth 2 Client\nclient: Client = get_client(\n  client_id_databricks_secret=(\"client-scope\", \"client-id-key\"),\n  client_secret_databricks_secret=(\"client-scope\", \"client-secret-key\"),\n  client_id_onepassword=\"op://Vault Name/Client ID Item Name/username\",\n  client_secret_onepassword=\"op://Vault Name/Client Secret Item Name/credential\",\n  client_id_environment_variable=\"MY_APP_CLIENT_ID\",\n  client_secret_environment_variable=\"MY_APP_CLIENT_SECRET\",\n)\n</code></pre>"},{"location":"cli/","title":"Command Line Interface","text":"<p>This package is primarily intended for use as a library, however exposes a handful of utility commands for shell use.</p> <pre><code>$ decorative-secrets -h\nUsage:\n  decorative-secrets &lt;secret-manager&gt; &lt;command&gt; [options]\n\nSecret Managers:\n  databricks\n  onepassword\n</code></pre>"},{"location":"cli/#decorative-secrets-databricks","title":"decorative-secrets databricks","text":"<pre><code>$ decorative-secrets databricks -h\nUsage:\n  decorative-secrets databricks &lt;command&gt; [options]\n\nCommands:\n  install\n  get\n</code></pre>"},{"location":"cli/#decorative-secrets-databricks-get","title":"decorative-secrets databricks get","text":"<pre><code>$ decorative-secrets databricks get -h\nusage: decorative-secrets databricks get\n       [-h] [--host HOST] [-cid CLIENT_ID]\n       [-cs CLIENT_SECRET] [-t TOKEN] [-p PROFILE]\n       scope key\n\nGet a secret from Databricks\n\npositional arguments:\n  scope\n  key\n\noptions:\n  -h, --help            show this help message and\n                        exit\n  --host HOST           A Databricks workspace\n                        host URL\n  -cid CLIENT_ID, --client-id CLIENT_ID\n                        A Databricks OAuth2 Client\n                        ID\n  -cs CLIENT_SECRET, --client-secret CLIENT_SECRET\n                        A Databricks OAuth2 Client\n                        Secret\n  -t TOKEN, --token TOKEN\n                        A Databricks Personal\n                        Access Token\n  -p PROFILE, --profile PROFILE\n                        A Databricks Configuration\n                        Profile$\n</code></pre>"},{"location":"cli/#decorative-secrets-databricks-install","title":"decorative-secrets databricks install","text":"<pre><code>$ decorative-secrets databricks install -h\nusage: decorative-secrets databricks install [-h]\n\nInstall the Databricks CLI\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre>"},{"location":"cli/#decorative-secrets-onepassword","title":"decorative-secrets onepassword","text":"<pre><code>$ decorative-secrets onepassword -h        \nUsage:\n  decorative-secrets onepassword &lt;command&gt; [options]\n\nCommands:\n  install\n  get\n</code></pre>"},{"location":"cli/#decorative-secrets-onepassword-get","title":"decorative-secrets onepassword get","text":"<pre><code>$ decorative-secrets onepassword get -h\nusage: decorative-secrets onepassword get\n       [-h] [--account ACCOUNT] [-t TOKEN]\n       [--host HOST]\n       reference\n\nGet a secret from 1Password\n\npositional arguments:\n  reference\n\noptions:\n  -h, --help            show this help message and\n                        exit\n  --account ACCOUNT     Which 1Password account to\n                        use\n  -t TOKEN, --token TOKEN\n                        A 1Password Service\n                        Account Token\n  --host HOST           A 1Password Connect Host\n                        URL\n</code></pre>"},{"location":"cli/#decorative-secrets-onepassword-install","title":"decorative-secrets onepassword install","text":"<pre><code>$ decorative-secrets onepassword install -h\nusage: decorative-secrets onepassword install [-h]\n\nInstall the 1Password CLI\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre>"},{"location":"contributing/","title":"Contributing to decorative-secrets","text":""},{"location":"contributing/#for-enorganic-contributors-and-code-owners","title":"For Enorganic Contributors and Code Owners","text":"<ol> <li> <p>Clone and Install</p> <p>To install this project for development of this library, clone this repository (replacing \"~/Code\", below, with the directory under which you want your project to reside), then run <code>make</code>:</p> <pre><code>cd ~/Code &amp;&amp; \\\ngit clone\\\nhttps://github.com/enorganic/decorative-secrets.git decorative-secrets &amp;&amp; \\\ncd decorative-secrets &amp;&amp; \\\nmake\n</code></pre> </li> <li> <p>Create a new branch for your changes (replacing \"descriptive-branch-name\"     with a descriptive branch name, and replacing feature with bugfix     if the branch addresses a bug):</p> <pre><code>git branch feature/descriptive-branch-name\n</code></pre> </li> <li> <p>Make some changes.</p> </li> <li> <p>Format and lint your code:</p> <pre><code>make format\n</code></pre> </li> <li> <p>Test your changes:</p> <pre><code>make test\n</code></pre> </li> <li> <p>Push your changes and create a pull request.</p> </li> </ol>"},{"location":"contributing/#for-everyone-else","title":"For Everyone Else","text":"<p>If you are not a contributor on this project, you can still create pull requests, however you will need to fork this project, push changes to your fork, and create a pull request from your forked repository.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 David Isaac Belais</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"api/callback/","title":"callback","text":""},{"location":"api/callback/#decorative_secrets.callback","title":"decorative_secrets.callback","text":""},{"location":"api/callback/#decorative_secrets.callback.apply_callback_arguments","title":"apply_callback_arguments","text":"<pre><code>apply_callback_arguments(\n    *callbacks: collections.abc.Callable[..., typing.Any],\n    **callback_parameter_names: str\n) -&gt; collections.abc.Callable[\n    ..., collections.abc.Callable[..., typing.Any]\n]\n</code></pre> <p>This decorator maps parameter names to callback arguments. Each key represents the name of a parameter in the decorated function which accepts an explicit input, and the corresponding mapped value is an argument to pass to the provided callback function(s).</p> <p>Parameters:</p> <ul> <li> <code>*callbacks</code>               (<code>collections.abc.Callable[..., typing.Any]</code>, default:                   <code>()</code> )           \u2013            <p>One or more callback functions. If both synchronous and asynchronous functions are provided, they will be used appropriately based on the decorated function's type, otherwise synchronous functions will be wrapped for asynchronous use and vice versa.</p> </li> <li> <code>**callback_parameter_names</code>               (<code>str</code>, default:                   <code>{}</code> )           \u2013            <p>A mapping of static parameter names to callback parameter names.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>collections.abc.Callable[..., collections.abc.Callable[..., typing.Any]]</code>           \u2013            <p>A decorator function which retrieves argument values by passing callback function arguments to the callback, and applying the output to their mapped static parameters.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @apply_callback_arguments(\n...     lambda x: x * 2,\n...     {\"x\": \"x_lookup_args\"},\n... )\n... def return_value(\n...     x: int | None = None,\n...     x_lookup_args: tuple[\n...         Sequence[int],\n...         Mapping[str, int],\n...     ]\n...     | None = None,\n... ) -&gt; int:\n...     return x**2\n&gt;&gt;&gt; return_value(\n...     x_lookup_args=(\n...         3,\n...         None,\n...     )\n... )\n36\n</code></pre> Source code in <code>src/decorative_secrets/callback.py</code> <pre><code>def apply_callback_arguments(  # noqa: C901\n    *callbacks: Callable[..., Any],\n    **callback_parameter_names: str,\n) -&gt; Callable[..., Callable[..., Any]]:\n    \"\"\"\n    This decorator maps parameter names to callback arguments.\n    Each key represents the name of a parameter in the decorated function\n    which accepts an explicit input, and the corresponding mapped value is\n    an argument to pass to the provided callback function(s).\n\n    Parameters:\n        *callbacks: One or more callback functions. If both synchronous and\n            asynchronous functions are provided, they will be used\n            appropriately based on the decorated function's type, otherwise\n            synchronous functions will be wrapped for asynchronous use\n            and vice versa.\n        **callback_parameter_names:\n            A mapping of static parameter names to callback parameter names.\n\n    Returns:\n        A decorator function which retrieves argument values by\n            passing callback function arguments to the callback, and\n            applying the output to their mapped static parameters.\n\n    Examples:\n        &gt;&gt;&gt; @apply_callback_arguments(\n        ...     lambda x: x * 2,\n        ...     {\"x\": \"x_lookup_args\"},\n        ... )\n        ... def return_value(\n        ...     x: int | None = None,\n        ...     x_lookup_args: tuple[\n        ...         Sequence[int],\n        ...         Mapping[str, int],\n        ...     ]\n        ...     | None = None,\n        ... ) -&gt; int:\n        ...     return x**2\n        &gt;&gt;&gt; return_value(\n        ...     x_lookup_args=(\n        ...         3,\n        ...         None,\n        ...     )\n        ... )\n        36\n    \"\"\"\n    callback: Callable[..., Any]\n    async_callback: Callable[..., Any]\n    callback, async_callback = _get_sync_async_callbacks(*callbacks)\n\n    def decorating_function(  # noqa: C901\n        function: Callable[..., Any],\n    ) -&gt; Callable[..., Any]:\n        original_function: Callable[..., Any] = unwrap_function(function)\n        function_signature: Signature = signature(original_function)\n\n        def get_args_kwargs(  # noqa: C901\n            *args: Any, **kwargs: Any\n        ) -&gt; tuple[tuple[Any, ...], dict[str, Any]]:\n            \"\"\"\n            This function performs lookups for any parameters for which an\n            argument is not passed explicitly.\n            \"\"\"\n            # Capture errors\n            errors: dict[str, list[str]] = get_errors(original_function)\n            # First we consolidate the keyword arguments with any arguments\n            # which are passed to parameters which can be either positional\n            # *or* keyword arguments, and were passed as positional arguments\n            args = merge_function_signature_args_kwargs(\n                function_signature, args, kwargs\n            )\n            # For any arguments where we have callback arguments and do not\n            # have an explicitly passed value, execute the callback\n            key: str\n            value: Any\n            used_keys: set[str] = {\n                key for key, value in kwargs.items() if value is not None\n            }\n            unused_callback_parameter_names: set[str] = (\n                set(callback_parameter_names.values()) &amp; used_keys\n            )\n            parameter_name: str\n            for parameter_name in (\n                set(callback_parameter_names.keys()) - used_keys\n            ):\n                callback_parameter_name: str = callback_parameter_names[\n                    parameter_name\n                ]\n                unused_callback_parameter_names.discard(\n                    callback_parameter_name\n                )\n                callback_argument: Any = kwargs.pop(\n                    callback_parameter_name, None\n                )\n                parameter: Parameter | None = (\n                    function_signature.parameters.get(parameter_name)\n                )\n                callback_: Callable[..., Any] = callback\n                if (\n                    (parameter is not None)\n                    and (isinstance(parameter.annotation, type))\n                    and issubclass(Coroutine, parameter.annotation)\n                ):\n                    callback_ = async_callback\n                if callback_argument is not None:\n                    try:\n                        kwargs[parameter_name] = callback_(callback_argument)\n                        # Clear preceding errors for this parameter\n                        errors.pop(parameter_name, None)\n                    except Exception:  # noqa: BLE001\n                        errors.setdefault(parameter_name, [])\n                        errors[parameter_name].append(get_exception_text())\n                elif callback_parameter_name in function_signature.parameters:\n                    default: tuple[Sequence[Any], Mapping[str, Any]] | None = (\n                        function_signature.parameters[\n                            callback_parameter_name\n                        ].default\n                    )\n                    if default not in (Signature.empty, None):\n                        try:\n                            kwargs[parameter_name] = callback_(default)\n                            # Clear preceding errors for this parameter\n                            errors.pop(parameter_name, None)\n                        except Exception:  # noqa: BLE001\n                            errors.setdefault(parameter_name, [])\n                            errors[parameter_name].append(get_exception_text())\n                if (function is original_function) and errors:\n                    arguments_error_messages: dict[str, list[str]] = {}\n                    for key, argument_error_messages in errors.items():\n                        # Don't raise an error for parameters which\n                        # have a value or default value\n                        if kwargs.get(key) is None:\n                            parameter = function_signature.parameters.get(key)\n                            if parameter and (\n                                parameter.default is Signature.empty\n                            ):\n                                arguments_error_messages[key] = (\n                                    argument_error_messages\n                                )\n                    # Clear global errors collection\n                    _FUNCTIONS_ERRORS.pop(id(function), None)\n                    if arguments_error_messages:\n                        raise ArgumentsResolutionError(\n                            arguments_error_messages\n                        )\n            # Remove unused callback arguments\n            deque(map(kwargs.pop, unused_callback_parameter_names), maxlen=0)\n            return (args, kwargs)\n\n        if iscoroutinefunction(function):\n\n            @wraps(function)\n            async def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n                \"\"\"\n                This function wraps the original and performs lookups for\n                any parameters for which an argument is not passed\n                \"\"\"\n                args, kwargs = get_args_kwargs(*args, **kwargs)\n                # Execute the wrapped function\n                return await function(*args, **kwargs)\n\n        else:\n\n            @wraps(function)\n            def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n                \"\"\"\n                This function wraps the original and performs lookups for\n                any parameters for which an argument is not passed\n                \"\"\"\n                args, kwargs = get_args_kwargs(*args, **kwargs)\n                # Execute the wrapped function\n                return function(*args, **kwargs)\n\n        return wrapper\n\n    return decorating_function\n</code></pre>"},{"location":"api/databricks/","title":"databricks","text":""},{"location":"api/databricks/#decorative_secrets.databricks","title":"decorative_secrets.databricks","text":""},{"location":"api/databricks/#decorative_secrets.databricks.DatabricksWorkspaceClientArguments","title":"DatabricksWorkspaceClientArguments  <code>dataclass</code>","text":"<p>An object holding arguments to pass to a Databricks workspace client if/when retrieving secrets remotely.</p> Source code in <code>src/decorative_secrets/databricks.py</code> <pre><code>@dataclass\nclass DatabricksWorkspaceClientArguments:\n    \"\"\"\n    An object holding arguments to pass to a Databricks workspace client\n    if/when retrieving secrets remotely.\n    \"\"\"\n\n    host: str | None = None\n    account_id: str | None = None\n    username: str | None = None\n    password: str | None = None\n    client_id: str | None = None\n    client_secret: str | None = None\n    token: str | None = None\n    profile: str | None = None\n    config_file: str | None = None\n    azure_workspace_resource_id: str | None = None\n    azure_client_secret: str | None = None\n    azure_client_id: str | None = None\n    azure_tenant_id: str | None = None\n    azure_environment: str | None = None\n    auth_type: str | None = None\n    cluster_id: str | None = None\n    google_credentials: str | None = None\n    google_service_account: str | None = None\n    debug_truncate_bytes: int | None = None\n    debug_headers: bool | None = None\n    product: str = \"unknown\"\n    product_version: str = \"0.0.0\"\n    credentials_strategy: CredentialsStrategy | None = None\n    credentials_provider: CredentialsStrategy | None = None\n    token_audience: str | None = None\n</code></pre>"},{"location":"api/databricks/#decorative_secrets.databricks.apply_databricks_secrets_arguments","title":"apply_databricks_secrets_arguments","text":"<pre><code>apply_databricks_secrets_arguments(\n    *args: decorative_secrets.databricks.DatabricksWorkspaceClientArguments,\n    **kwargs: str\n) -&gt; collections.abc.Callable\n</code></pre> <p>This decorator maps parameter names to Databricks secrets. Each key in <code>databricks_secret_arguments</code> represents the name of a parameter in the decorated function which accepts an explicit input, and the corresponding mapped value is a parameter name accepting a tuple with the secret scope and key with which to lookup a secret to pass to the mapped parameter in lieu of an explicitly provided argument.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>               (<code>decorative_secrets.databricks.DatabricksWorkspaceClientArguments</code>, default:                   <code>()</code> )           \u2013            <p>A <code>DatabricksWorkspaceConfigArguments</code> instance to configure a workspace client when retrieving secrets remotely (if more than one  is provided, only the first is used).</p> </li> <li> <code>**kwargs</code>               (<code>str</code>, default:                   <code>{}</code> )           \u2013            <p>A mapping of static parameter names to the parameter names of arguments accepting Databricks secret scope + key tuples from which to retrieve a value when the key argument is not explicitly provided.</p> </li> </ul> Example <pre><code>from functools import (\n    cache,\n)\nfrom decorative_secrets.databricks import (\n    apply_databricks_secret_arguments,\n)\nfrom my_client_sdk import (\n    Client,\n)\n\n\n@cache\n@apply_databricks_secret_arguments(\n    client_id=\"client_id_databricks_secret\",\n    client_secret=\"client_secret_databricks_secret\",\n)\ndef get_client(\n    client_id: str | None = None,\n    client_secret: str = None,\n    client_id_databricks_secret: str | None = None,\n    client_secret_databricks_secret: str | None = None,\n) -&gt; Client:\n    return Client(\n        oauth2_client_id=client_id,\n        oauth2_client_secret=client_secret,\n    )\n\n\nclient: Client = get_client(\n    client_id_databricks_secret=(\n        \"client\",\n        \"client-id\",\n    ),\n    client_secret_databricks_secret=(\n        \"client\",\n        \"client-secret\",\n    ),\n)\n</code></pre> Source code in <code>src/decorative_secrets/databricks.py</code> <pre><code>def apply_databricks_secrets_arguments(\n    *args: DatabricksWorkspaceClientArguments,\n    **kwargs: str,\n) -&gt; Callable:\n    \"\"\"\n    This decorator maps parameter names to Databricks secrets.\n    Each key in `databricks_secret_arguments` represents the name of a\n    parameter in the decorated function which accepts an explicit input, and\n    the corresponding mapped value is a parameter name accepting a tuple with\n    the secret scope and key with which to lookup a secret to pass to the\n    mapped parameter in lieu of an explicitly provided argument.\n\n    Parameters:\n        *args: A `DatabricksWorkspaceConfigArguments` instance to configure\n            a workspace client when retrieving secrets remotely\n            (if more than one  is provided, only the first is used).\n        **kwargs: A mapping of static parameter names to the parameter names\n            of arguments accepting Databricks secret scope + key tuples\n            from which to retrieve a value when the key argument is not\n            explicitly provided.\n\n    Example:\n        ```python\n        from functools import (\n            cache,\n        )\n        from decorative_secrets.databricks import (\n            apply_databricks_secret_arguments,\n        )\n        from my_client_sdk import (\n            Client,\n        )\n\n\n        @cache\n        @apply_databricks_secret_arguments(\n            client_id=\"client_id_databricks_secret\",\n            client_secret=\"client_secret_databricks_secret\",\n        )\n        def get_client(\n            client_id: str | None = None,\n            client_secret: str = None,\n            client_id_databricks_secret: str | None = None,\n            client_secret_databricks_secret: str | None = None,\n        ) -&gt; Client:\n            return Client(\n                oauth2_client_id=client_id,\n                oauth2_client_secret=client_secret,\n            )\n\n\n        client: Client = get_client(\n            client_id_databricks_secret=(\n                \"client\",\n                \"client-id\",\n            ),\n            client_secret_databricks_secret=(\n                \"client\",\n                \"client-secret\",\n            ),\n        )\n        ```\n    \"\"\"\n    databricks_workspace_client_arguments: (\n        DatabricksWorkspaceClientArguments | None\n    ) = _get_args_options(*args)[1]\n    get_scope_key_secret: Callable[[str | tuple[str, str]], str] = (\n        partial(\n            _get_scope_key_secret,\n            **asdict(databricks_workspace_client_arguments),\n        )\n        if databricks_workspace_client_arguments\n        else _get_scope_key_secret\n    )\n    return apply_callback_arguments(\n        get_scope_key_secret,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/databricks/#decorative_secrets.databricks.which_databricks","title":"which_databricks","text":"<pre><code>which_databricks() -&gt; str\n</code></pre> <p>Find the <code>databricks</code> executable, or install the Databricks CLI if not found.</p> Source code in <code>src/decorative_secrets/databricks.py</code> <pre><code>def which_databricks() -&gt; str:\n    \"\"\"\n    Find the `databricks` executable, or install the Databricks CLI if not\n    found.\n    \"\"\"\n    databricks: str = which(\"databricks\") or \"databricks\"\n    try:\n        check_output((databricks, \"--version\"))\n    except (CalledProcessError, FileNotFoundError):\n        _install_databricks_cli()\n        databricks = which(\"databricks\") or \"databricks\"\n    return databricks\n</code></pre>"},{"location":"api/databricks/#decorative_secrets.databricks.databricks_auth_login","title":"databricks_auth_login","text":"<pre><code>databricks_auth_login(\n    host: str | None = None,\n    profile: str | None = None,\n    target: str | None = None,\n) -&gt; None\n</code></pre> <p>Log in to Databricks using the CLI if not already logged in.</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks workspace host URL.</p> </li> <li> <code>profile</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks Configuration Profile.</p> </li> <li> <code>target</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks CLI target.</p> </li> </ul> Source code in <code>src/decorative_secrets/databricks.py</code> <pre><code>def databricks_auth_login(\n    host: str | None = None,\n    profile: str | None = None,\n    target: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Log in to Databricks using the CLI if not already logged in.\n\n    Parameters:\n        host: A Databricks workspace host URL.\n        profile: A Databricks Configuration Profile.\n        target: A Databricks CLI target.\n    \"\"\"\n    if (host is None) and (profile is None) and (target is None):\n        host = os.getenv(\"DATABRICKS_HOST\")\n        profile = os.getenv(\"DATABRICKS_CONFIG_PROFILE\")\n    # with suppress(CalledProcessError):\n    # If we are already authenticated, don't attempt to log in again\n    if (\n        _databricks_auth_describe(\n            host=host, profile=profile, target=target\n        ).get(\"status\")\n        == \"success\"\n    ):\n        return\n    return _databricks_auth_login(host=host, profile=profile, target=target)\n</code></pre>"},{"location":"api/databricks/#decorative_secrets.databricks.get_databricks_workspace_client","title":"get_databricks_workspace_client","text":"<pre><code>get_databricks_workspace_client(\n    host: str | None = None,\n    account_id: str | None = None,\n    username: str | None = None,\n    password: str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    token: str | None = None,\n    profile: str | None = None,\n    config_file: str | None = None,\n    azure_workspace_resource_id: str | None = None,\n    azure_client_secret: str | None = None,\n    azure_client_id: str | None = None,\n    azure_tenant_id: str | None = None,\n    azure_environment: str | None = None,\n    auth_type: str | None = None,\n    cluster_id: str | None = None,\n    google_credentials: str | None = None,\n    google_service_account: str | None = None,\n    debug_truncate_bytes: int | None = None,\n    *,\n    debug_headers: bool | None = None,\n    product: str = \"unknown\",\n    product_version: str = \"0.0.0\",\n    credentials_strategy: (\n        databricks.sdk.credentials_provider.CredentialsStrategy\n        | None\n    ) = None,\n    credentials_provider: (\n        databricks.sdk.credentials_provider.CredentialsStrategy\n        | None\n    ) = None,\n    token_audience: str | None = None,\n    config: databricks.sdk.config.Config | None = None\n) -&gt; databricks.sdk.WorkspaceClient\n</code></pre> <p>Get a Databricks WorkspaceClient configured from environment variables.</p> Source code in <code>src/decorative_secrets/databricks.py</code> <pre><code>def get_databricks_workspace_client(\n    host: str | None = None,\n    account_id: str | None = None,\n    username: str | None = None,\n    password: str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    token: str | None = None,\n    profile: str | None = None,\n    config_file: str | None = None,\n    azure_workspace_resource_id: str | None = None,\n    azure_client_secret: str | None = None,\n    azure_client_id: str | None = None,\n    azure_tenant_id: str | None = None,\n    azure_environment: str | None = None,\n    auth_type: str | None = None,\n    cluster_id: str | None = None,\n    google_credentials: str | None = None,\n    google_service_account: str | None = None,\n    debug_truncate_bytes: int | None = None,\n    *,\n    debug_headers: bool | None = None,\n    product: str = \"unknown\",\n    product_version: str = \"0.0.0\",\n    credentials_strategy: CredentialsStrategy | None = None,\n    credentials_provider: CredentialsStrategy | None = None,\n    token_audience: str | None = None,\n    config: Config | None = None,\n) -&gt; WorkspaceClient:\n    \"\"\"\n    Get a Databricks WorkspaceClient configured from environment variables.\n    \"\"\"\n    return _get_env_databricks_workspace_client(\n        host=host,\n        account_id=account_id,\n        username=username,\n        password=password,\n        client_id=client_id,\n        client_secret=client_secret,\n        token=token,\n        profile=profile,\n        config_file=config_file,\n        azure_workspace_resource_id=azure_workspace_resource_id,\n        azure_client_secret=azure_client_secret,\n        azure_client_id=azure_client_id,\n        azure_tenant_id=azure_tenant_id,\n        azure_environment=azure_environment,\n        auth_type=auth_type,\n        cluster_id=cluster_id,\n        google_credentials=google_credentials,\n        google_service_account=google_service_account,\n        debug_truncate_bytes=debug_truncate_bytes,\n        debug_headers=debug_headers,\n        product=product,\n        product_version=product_version,\n        credentials_strategy=credentials_strategy,\n        credentials_provider=credentials_provider,\n        token_audience=token_audience,\n        config=config,\n        **os.environ,\n    )\n</code></pre>"},{"location":"api/databricks/#decorative_secrets.databricks.get_dbutils","title":"get_dbutils","text":"<pre><code>get_dbutils(\n    host: str | None = None,\n    account_id: str | None = None,\n    username: str | None = None,\n    password: str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    token: str | None = None,\n    profile: str | None = None,\n    config_file: str | None = None,\n    azure_workspace_resource_id: str | None = None,\n    azure_client_secret: str | None = None,\n    azure_client_id: str | None = None,\n    azure_tenant_id: str | None = None,\n    azure_environment: str | None = None,\n    auth_type: str | None = None,\n    cluster_id: str | None = None,\n    google_credentials: str | None = None,\n    google_service_account: str | None = None,\n    debug_truncate_bytes: int | None = None,\n    *,\n    debug_headers: bool | None = None,\n    product: str = \"unknown\",\n    product_version: str = \"0.0.0\",\n    credentials_strategy: (\n        databricks.sdk.credentials_provider.CredentialsStrategy\n        | None\n    ) = None,\n    credentials_provider: (\n        databricks.sdk.credentials_provider.CredentialsStrategy\n        | None\n    ) = None,\n    token_audience: str | None = None,\n    config: databricks.sdk.config.Config | None = None\n) -&gt; databricks.sdk.dbutils.RemoteDbUtils\n</code></pre> <p>Get dbutils using an existing instance from the runtime if found, otherwise, creating one using a workspace client (this requires either having these environment variables set , or providing the equivalent optional arguments.</p> Source code in <code>src/decorative_secrets/databricks.py</code> <pre><code>def get_dbutils(\n    host: str | None = None,\n    account_id: str | None = None,\n    username: str | None = None,\n    password: str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    token: str | None = None,\n    profile: str | None = None,\n    config_file: str | None = None,\n    azure_workspace_resource_id: str | None = None,\n    azure_client_secret: str | None = None,\n    azure_client_id: str | None = None,\n    azure_tenant_id: str | None = None,\n    azure_environment: str | None = None,\n    auth_type: str | None = None,\n    cluster_id: str | None = None,\n    google_credentials: str | None = None,\n    google_service_account: str | None = None,\n    debug_truncate_bytes: int | None = None,\n    *,\n    debug_headers: bool | None = None,\n    product: str = \"unknown\",\n    product_version: str = \"0.0.0\",\n    credentials_strategy: CredentialsStrategy | None = None,\n    credentials_provider: CredentialsStrategy | None = None,\n    token_audience: str | None = None,\n    config: Config | None = None,\n) -&gt; RemoteDbUtils:  # pragma: no cover - environment dependent\n    \"\"\"\n    Get [dbutils](https://docs.databricks.com/dev-tools/databricks-utils.html)\n    using an existing instance from the runtime if found, otherwise,\n    creating one using a workspace client (this requires either having\n    [these environment variables set\n    ](https://docs.databricks.com/aws/en/dev-tools/auth#environment-variables),\n    or providing the equivalent optional arguments.\n    \"\"\"\n    dbutils: RemoteDbUtils | None = None\n    with suppress(ImportError):\n        from IPython.core.getipython import (  # type: ignore[import-not-found]  # noqa: PLC0415\n            get_ipython,\n        )\n\n        if TYPE_CHECKING:\n            from IPython.core.interactiveshell import (  # type: ignore[import-not-found]  # noqa: PLC0415\n                InteractiveShell,\n            )\n\n        ipython: InteractiveShell = get_ipython()\n        if ipython is not None:\n            user_namespace_attribute: str\n            user_namespace: dict\n            for user_namespace_attribute in \"user_ns\", \"user_global_ns\":\n                dbutils = getattr(ipython, user_namespace_attribute, {}).get(\n                    \"dbutils\", None\n                )\n                if dbutils is not None:\n                    return dbutils\n    dbutils = globals().get(\"dbutils\")\n    if dbutils is not None:\n        return dbutils\n    databricks_workspace_client: WorkspaceClient = (\n        get_databricks_workspace_client(\n            host=host,\n            account_id=account_id,\n            username=username,\n            password=password,\n            client_id=client_id,\n            client_secret=client_secret,\n            token=token,\n            profile=profile,\n            config_file=config_file,\n            azure_workspace_resource_id=azure_workspace_resource_id,\n            azure_client_secret=azure_client_secret,\n            azure_client_id=azure_client_id,\n            azure_tenant_id=azure_tenant_id,\n            azure_environment=azure_environment,\n            auth_type=auth_type,\n            cluster_id=cluster_id,\n            google_credentials=google_credentials,\n            google_service_account=google_service_account,\n            debug_truncate_bytes=debug_truncate_bytes,\n            debug_headers=debug_headers,\n            product=product,\n            product_version=product_version,\n            credentials_strategy=credentials_strategy,\n            credentials_provider=credentials_provider,\n            token_audience=token_audience,\n            config=config,\n        )\n    )\n    return databricks_workspace_client.dbutils\n</code></pre>"},{"location":"api/databricks/#decorative_secrets.databricks.get_databricks_secret","title":"get_databricks_secret","text":"<pre><code>get_databricks_secret(\n    scope: str,\n    key: str,\n    host: str | None = None,\n    account_id: str | None = None,\n    username: str | None = None,\n    password: str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    token: str | None = None,\n    profile: str | None = None,\n    config_file: str | None = None,\n    azure_workspace_resource_id: str | None = None,\n    azure_client_secret: str | None = None,\n    azure_client_id: str | None = None,\n    azure_tenant_id: str | None = None,\n    azure_environment: str | None = None,\n    auth_type: str | None = None,\n    cluster_id: str | None = None,\n    google_credentials: str | None = None,\n    google_service_account: str | None = None,\n    debug_truncate_bytes: int | None = None,\n    *,\n    debug_headers: bool | None = None,\n    product: str = \"unknown\",\n    product_version: str = \"0.0.0\",\n    credentials_strategy: (\n        databricks.sdk.credentials_provider.CredentialsStrategy\n        | None\n    ) = None,\n    credentials_provider: (\n        databricks.sdk.credentials_provider.CredentialsStrategy\n        | None\n    ) = None,\n    token_audience: str | None = None,\n    config: databricks.sdk.config.Config | None = None\n) -&gt; str\n</code></pre> <p>Get a secret from Databricks.</p> <p>Parameters:</p> <ul> <li> <code>scope</code>               (<code>str</code>)           \u2013            <p>The Databricks secret scope.</p> </li> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The Databricks secret key.</p> </li> <li> <code>host</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks workspace host URL.</p> </li> <li> <code>account_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks account ID.</p> </li> <li> <code>username</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks username.</p> </li> <li> <code>password</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks password.</p> </li> <li> <code>client_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks OAuth2 Client ID.</p> </li> <li> <code>client_secret</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks OAuth2 Client Secret.</p> </li> <li> <code>token</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks Personal Access Token.</p> </li> <li> <code>profile</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks Configuration Profile.</p> </li> <li> <code>config_file</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks Configuration File path.</p> </li> <li> <code>azure_workspace_resource_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An Azure Databricks Workspace Resource ID.</p> </li> <li> <code>azure_client_secret</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An Azure Client Secret for Azure Databricks auth.</p> </li> <li> <code>azure_client_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An Azure Client ID for Azure Databricks auth.</p> </li> <li> <code>azure_tenant_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An Azure Tenant ID for Azure Databricks auth.</p> </li> <li> <code>azure_environment</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An Azure Environment for Azure Databricks auth.</p> </li> <li> <code>auth_type</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks authentication type.</p> </li> <li> <code>cluster_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks cluster ID.</p> </li> <li> <code>google_credentials</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Google Cloud credentials for GCP Databricks auth.</p> </li> <li> <code>google_service_account</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A Google Service Account for GCP Databricks auth.</p> </li> <li> <code>debug_truncate_bytes</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of bytes to truncate in debug logs.</p> </li> <li> <code>debug_headers</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debug logging of HTTP headers.</p> </li> <li> <code>product</code>               (<code>str</code>, default:                   <code>'unknown'</code> )           \u2013            <p>The product name using the SDK.</p> </li> <li> <code>product_version</code>               (<code>str</code>, default:                   <code>'0.0.0'</code> )           \u2013            <p>The product version using the SDK.</p> </li> <li> <code>credentials_strategy</code>               (<code>databricks.sdk.credentials_provider.CredentialsStrategy | None</code>, default:                   <code>None</code> )           \u2013            <p>A credentials strategy for the SDK.</p> </li> <li> <code>credentials_provider</code>               (<code>databricks.sdk.credentials_provider.CredentialsStrategy | None</code>, default:                   <code>None</code> )           \u2013            <p>A credentials provider for the SDK.</p> </li> <li> <code>token_audience</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A token audience for the SDK.</p> </li> <li> <code>config</code>               (<code>databricks.sdk.config.Config | None</code>, default:                   <code>None</code> )           \u2013            <p>A Databricks SDK Config instance.</p> </li> </ul> Source code in <code>src/decorative_secrets/databricks.py</code> <pre><code>def get_databricks_secret(\n    scope: str,\n    key: str,\n    host: str | None = None,\n    account_id: str | None = None,\n    username: str | None = None,\n    password: str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    token: str | None = None,\n    profile: str | None = None,\n    config_file: str | None = None,\n    azure_workspace_resource_id: str | None = None,\n    azure_client_secret: str | None = None,\n    azure_client_id: str | None = None,\n    azure_tenant_id: str | None = None,\n    azure_environment: str | None = None,\n    auth_type: str | None = None,\n    cluster_id: str | None = None,\n    google_credentials: str | None = None,\n    google_service_account: str | None = None,\n    debug_truncate_bytes: int | None = None,\n    *,\n    debug_headers: bool | None = None,\n    product: str = \"unknown\",\n    product_version: str = \"0.0.0\",\n    credentials_strategy: CredentialsStrategy | None = None,\n    credentials_provider: CredentialsStrategy | None = None,\n    token_audience: str | None = None,\n    config: Config | None = None,\n) -&gt; str:\n    \"\"\"\n    Get a secret from Databricks.\n\n    Parameters:\n        scope: The Databricks secret scope.\n        key: The Databricks secret key.\n        host: A Databricks workspace host URL.\n        account_id: A Databricks account ID.\n        username: A Databricks username.\n        password: A Databricks password.\n        client_id: A Databricks OAuth2 Client ID.\n        client_secret: A Databricks OAuth2 Client Secret.\n        token: A Databricks Personal Access Token.\n        profile: A Databricks Configuration Profile.\n        config_file: A Databricks Configuration File path.\n        azure_workspace_resource_id: An Azure Databricks Workspace Resource ID.\n        azure_client_secret: An Azure Client Secret for Azure Databricks auth.\n        azure_client_id: An Azure Client ID for Azure Databricks auth.\n        azure_tenant_id: An Azure Tenant ID for Azure Databricks auth.\n        azure_environment: An Azure Environment for Azure Databricks auth.\n        auth_type: A Databricks authentication type.\n        cluster_id: A Databricks cluster ID.\n        google_credentials: Google Cloud credentials for GCP Databricks auth.\n        google_service_account: A Google Service Account for GCP Databricks\n            auth.\n        debug_truncate_bytes: Number of bytes to truncate in debug logs.\n        debug_headers: Whether to enable debug logging of HTTP headers.\n        product: The product name using the SDK.\n        product_version: The product version using the SDK.\n        credentials_strategy: A credentials strategy for the SDK.\n        credentials_provider: A credentials provider for the SDK.\n        token_audience: A token audience for the SDK.\n        config: A Databricks SDK Config instance.\n    \"\"\"\n    return _get_secret(\n        scope,\n        key,\n        host=host,\n        account_id=account_id,\n        username=username,\n        password=password,\n        client_id=client_id,\n        client_secret=client_secret,\n        token=token,\n        profile=profile,\n        config_file=config_file,\n        azure_workspace_resource_id=azure_workspace_resource_id,\n        azure_client_secret=azure_client_secret,\n        azure_client_id=azure_client_id,\n        azure_tenant_id=azure_tenant_id,\n        azure_environment=azure_environment,\n        auth_type=auth_type,\n        cluster_id=cluster_id,\n        google_credentials=google_credentials,\n        google_service_account=google_service_account,\n        debug_truncate_bytes=debug_truncate_bytes,\n        debug_headers=debug_headers,\n        product=product,\n        product_version=product_version,\n        credentials_strategy=credentials_strategy,\n        credentials_provider=credentials_provider,\n        token_audience=token_audience,\n        config=config,\n        **os.environ,\n    )\n</code></pre>"},{"location":"api/databricks/#decorative_secrets.databricks.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Run a command: -   install: Install the Databricks CLI if not already installed -   get: Get a secret from Databricks and print it to stdout</p> Source code in <code>src/decorative_secrets/databricks.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Run a command:\n    -   install: Install the Databricks CLI if not already installed\n    -   get: Get a secret from Databricks and print it to stdout\n    \"\"\"\n    command = _get_command()\n    if command in (\"--help\", \"-h\"):\n        _print_help()\n        return\n    parser: argparse.ArgumentParser\n    if command == \"install\":\n        parser = argparse.ArgumentParser(\n            prog=\"decorative-secrets databricks install\",\n            description=\"Install the Databricks CLI\",\n        )\n        parser.parse_args()\n        _install_databricks_cli()\n    elif command == \"get\":\n        parser = argparse.ArgumentParser(\n            prog=\"decorative-secrets databricks get\",\n            description=\"Get a secret from Databricks\",\n        )\n        parser.add_argument(\n            \"scope\",\n            type=str,\n        )\n        parser.add_argument(\n            \"key\",\n            type=str,\n        )\n        parser.add_argument(\n            \"--host\",\n            default=None,\n            type=str,\n            help=\"A Databricks workspace host URL\",\n        )\n        parser.add_argument(\n            \"-cid\",\n            \"--client-id\",\n            default=None,\n            type=str,\n            help=\"A Databricks OAuth2 Client ID\",\n        )\n        parser.add_argument(\n            \"-cs\",\n            \"--client-secret\",\n            default=None,\n            type=str,\n            help=\"A Databricks OAuth2 Client Secret\",\n        )\n        parser.add_argument(\n            \"-t\",\n            \"--token\",\n            default=None,\n            type=str,\n            help=\"A Databricks Personal Access Token\",\n        )\n        parser.add_argument(\n            \"-p\",\n            \"--profile\",\n            default=None,\n            type=str,\n            help=\"A Databricks Configuration Profile\",\n        )\n        namespace: argparse.Namespace = parser.parse_args()\n        print(  # noqa: T201\n            get_databricks_secret(\n                namespace.scope,\n                namespace.key,\n                host=namespace.host,\n                client_id=namespace.client_id,\n                client_secret=namespace.client_secret,\n                token=namespace.token,\n                profile=namespace.profile,\n            )\n        )\n</code></pre>"},{"location":"api/defaults/","title":"defaults","text":""},{"location":"api/defaults/#decorative_secrets.defaults","title":"decorative_secrets.defaults","text":""},{"location":"api/defaults/#decorative_secrets.defaults.ApplyConditionalDefaultsOptions","title":"ApplyConditionalDefaultsOptions  <code>dataclass</code>","text":"<p>This class contains options governing the behavior of the apply_conditional_defaults  decorator.</p> <p>Attributes:</p> <ul> <li> <code>filter_parameter_defaults</code>               (<code>tuple[typing.Any, ...] | dict[str, tuple[typing.Any, ...]]</code>)           \u2013            <p>This may either be:</p> <ol> <li>A tuple of values which should be filtered out of keyword     arguments when both the passed keyword argument value and     the parameter default value in the function signature     are one of these values.</li> <li>A dictionary mapping parameter names to tuples of values     applying the filtering logic described above on a per-parameter     basis.</li> </ol> <p>Defaults to <code>()</code>\u2014indicating no filtering should occur.</p> </li> </ul> <p>Examples:</p> <pre><code>from decorative_secrets.defaults import (\n    apply_conditional_defaults,\n    ApplyConditionalDefaultsOptions,\n)\n@apply_conditional_defaults(\n    lambda environment: environment == \"prod\",\n    ApplyConditionalDefaultsOptions(filter_parameter_defaults=(None,)),\n    source_directory=\"/in/prod\",\n    target_directory=\"/out/prod\",\n)\n@apply_conditional_defaults(\n    lambda environment: environment == \"dev\",\n    ApplyConditionalDefaultsOptions(filter_parameter_defaults=(None,)),\n    source_directory=\"/in/dev\",\n    target_directory=\"/out/dev\",\n)\n@apply_conditional_defaults(\n    lambda environment: environment == \"stage\",\n    ApplyConditionalDefaultsOptions(filter_parameter_defaults=(None,)),\n    source_directory=\"/in/stage\",\n    target_directory=\"/out/stage\",\n)\ndef get_environment_source_target(\n    environment: str = \"dev\",\n    source_directory: str | None = None,\n    target_directory: str | None = None,\n) -&gt; tuple[str, str | None, str | None]:\n    return (environment, source_directory, target_directory)\n\nget_environment_source_target(\"stage\", None, None)\n# ('stage', '/in/stage', '/out/stage')\n\nget_environment_source_target(environment=\"prod\", None, None)\n# ('prod', '/in/prod', '/out/prod')\n\nget_environment_source_target(None, None, None)\n# ('dev', '/in/dev', '/out/dev')\n</code></pre> Source code in <code>src/decorative_secrets/defaults.py</code> <pre><code>@dataclass(frozen=True)\nclass ApplyConditionalDefaultsOptions:\n    \"\"\"\n    This class contains options governing the behavior of the\n    [apply_conditional_defaults\n    ](./#decorative_secrets.defaults.apply_conditional_defaults) decorator.\n\n    Attributes:\n        filter_parameter_defaults: This may either be:\n\n            1.  A tuple of values which should be filtered out of keyword\n                arguments when both the passed keyword argument value *and*\n                the parameter default value in the function signature\n                are one of these values.\n            2.  A dictionary mapping parameter names to tuples of values\n                applying the filtering logic described above on a per-parameter\n                basis.\n\n            Defaults to `()`\u2014indicating no filtering should occur.\n\n    Examples:\n        ```python\n        from decorative_secrets.defaults import (\n            apply_conditional_defaults,\n            ApplyConditionalDefaultsOptions,\n        )\n        @apply_conditional_defaults(\n            lambda environment: environment == \"prod\",\n            ApplyConditionalDefaultsOptions(filter_parameter_defaults=(None,)),\n            source_directory=\"/in/prod\",\n            target_directory=\"/out/prod\",\n        )\n        @apply_conditional_defaults(\n            lambda environment: environment == \"dev\",\n            ApplyConditionalDefaultsOptions(filter_parameter_defaults=(None,)),\n            source_directory=\"/in/dev\",\n            target_directory=\"/out/dev\",\n        )\n        @apply_conditional_defaults(\n            lambda environment: environment == \"stage\",\n            ApplyConditionalDefaultsOptions(filter_parameter_defaults=(None,)),\n            source_directory=\"/in/stage\",\n            target_directory=\"/out/stage\",\n        )\n        def get_environment_source_target(\n            environment: str = \"dev\",\n            source_directory: str | None = None,\n            target_directory: str | None = None,\n        ) -&gt; tuple[str, str | None, str | None]:\n            return (environment, source_directory, target_directory)\n\n        get_environment_source_target(\"stage\", None, None)\n        # ('stage', '/in/stage', '/out/stage')\n\n        get_environment_source_target(environment=\"prod\", None, None)\n        # ('prod', '/in/prod', '/out/prod')\n\n        get_environment_source_target(None, None, None)\n        # ('dev', '/in/dev', '/out/dev')\n        ```\n    \"\"\"\n\n    filter_parameter_defaults: (\n        tuple[Any, ...] | dict[str, tuple[Any, ...]]\n    ) = ()\n</code></pre>"},{"location":"api/defaults/#decorative_secrets.defaults.apply_conditional_defaults","title":"apply_conditional_defaults","text":"<pre><code>apply_conditional_defaults(\n    condition: collections.abc.Callable[..., bool],\n    *default_args: typing.Any,\n    **default_kwargs: typing.Any\n) -&gt; collections.abc.Callable[\n    ..., collections.abc.Callable[..., typing.Any]\n]\n</code></pre> <p>This function decorates another function in order to apply a set of default keyword or positional/keyword argument values dependent on the outcome of passing an applicable subset of those arguments to the <code>condition</code> function.</p> <p>Parameters:</p> <ul> <li> <code>condition</code>               (<code>collections.abc.Callable[..., bool]</code>)           \u2013            <p>A function which accepts a subset of the decorated function's arguments and returns a boolean value indicating whether or not to apply the default argument values.</p> </li> <li> <code>*default_args</code>               (<code>typing.Any</code>, default:                   <code>()</code> )           \u2013            <p>A set of positional argument values to apply as defaults if the condition is met. Note: If any of these arguments are an instance of ApplyConditionalDefaultsOptions , the options will be used to determine decorator behavior, and will be redacted from the arguments passed to the decorated function.</p> </li> <li> <code>**default_kwargs</code>               (<code>typing.Any</code>, default:                   <code>{}</code> )           \u2013            <p>A set of keyword argument values to apply as defaults if the condition is met.</p> </li> </ul> <p>Examples:</p> <pre><code>from decorative_secrets.defaults import apply_conditional_defaults\n\n\n@apply_conditional_defaults(\n    lambda environment: environment == \"prod\",\n    source_directory=\"/in/prod\",\n    target_directory=\"/out/prod\",\n)\n@apply_conditional_defaults(\n    lambda environment: environment == \"dev\",\n    source_directory=\"/in/dev\",\n    target_directory=\"/out/dev\",\n)\n@apply_conditional_defaults(\n    lambda environment: environment == \"stage\",\n    source_directory=\"/in/stage\",\n    target_directory=\"/out/stage\",\n)\ndef get_environment_source_target(\n    environment: str = \"dev\",\n    source_directory: str = \"/dev/null\",\n    target_directory: str = \"/dev/null\",\n) -&gt; tuple[str, str, str]:\n    return (environment, source_directory, target_directory)\n\n\nget_environment_source_target(\"stage\")\n# ('stage', '/in/stage', '/out/stage')\n\nget_environment_source_target(environment=\"prod\")\n# ('prod', '/in/prod', '/out/prod')\n\nget_environment_source_target()\n# ('dev', '/in/dev', '/out/dev')\n</code></pre> Source code in <code>src/decorative_secrets/defaults.py</code> <pre><code>def apply_conditional_defaults(\n    condition: Callable[..., bool], *default_args: Any, **default_kwargs: Any\n) -&gt; Callable[..., Callable[..., Any]]:\n    \"\"\"\n    This function decorates another function in order to apply a set of\n    *default* keyword or positional/keyword argument values dependent on the\n    outcome of passing an applicable subset of those arguments to the\n    `condition` function.\n\n    Parameters:\n        condition: A function which accepts a subset of the decorated\n            function's arguments and returns a boolean value indicating\n            whether or not to apply the default argument values.\n        *default_args: A set of positional argument values to apply as\n            defaults if the condition is met. Note: If any of these arguments\n            are an instance of [ApplyConditionalDefaultsOptions\n            ](./#decorative_secrets.defaults.ApplyConditionalDefaultsOptions),\n            the options will be used to determine decorator behavior, and will\n            be redacted from the arguments passed to the decorated function.\n        **default_kwargs: A set of keyword argument values to apply as\n            defaults if the condition is met.\n\n    Examples:\n        ```python\n        from decorative_secrets.defaults import apply_conditional_defaults\n\n\n        @apply_conditional_defaults(\n            lambda environment: environment == \"prod\",\n            source_directory=\"/in/prod\",\n            target_directory=\"/out/prod\",\n        )\n        @apply_conditional_defaults(\n            lambda environment: environment == \"dev\",\n            source_directory=\"/in/dev\",\n            target_directory=\"/out/dev\",\n        )\n        @apply_conditional_defaults(\n            lambda environment: environment == \"stage\",\n            source_directory=\"/in/stage\",\n            target_directory=\"/out/stage\",\n        )\n        def get_environment_source_target(\n            environment: str = \"dev\",\n            source_directory: str = \"/dev/null\",\n            target_directory: str = \"/dev/null\",\n        ) -&gt; tuple[str, str, str]:\n            return (environment, source_directory, target_directory)\n\n\n        get_environment_source_target(\"stage\")\n        # ('stage', '/in/stage', '/out/stage')\n\n        get_environment_source_target(environment=\"prod\")\n        # ('prod', '/in/prod', '/out/prod')\n\n        get_environment_source_target()\n        # ('dev', '/in/dev', '/out/dev')\n        ```\n    \"\"\"\n    options: ApplyConditionalDefaultsOptions\n    default_args, options = _get_args_options(*default_args)\n\n    def decorating_function(\n        function: Callable[..., Any],\n    ) -&gt; Callable[..., Any]:\n        original_function: Callable[..., Any] = unwrap_function(function)\n        function_signature: Signature = signature(original_function)\n        condition_signature: Signature = signature(condition)\n\n        def get_args_kwargs(\n            *args: Any, **kwargs: Any\n        ) -&gt; tuple[tuple[Any, ...], dict[str, Any]]:\n            # First we consolidate the keyword arguments with any arguments\n            # which are passed to parameters which can be either positional\n            # *or* keyword arguments, and were passed as positional arguments\n            args = merge_function_signature_args_kwargs(\n                function_signature, args, kwargs\n            )\n            # Get the arguments and keyword arguments applicable to the\n            # condition function\n            condition_args: tuple[Any, ...]\n            condition_kwargs: dict[str, Any]\n            kwargs_or_defaults: dict[str, Any] = kwargs.copy()\n            # Use function signature defaults for any missing keyword\n            # parameters\n            key: str\n            value: Any\n            for key, value in get_signature_parameter_names_defaults(\n                function_signature\n            ).items():\n                if (\n                    options.filter_parameter_defaults\n                    and (value in options.filter_parameter_defaults)\n                    and (key in kwargs)\n                    and (kwargs[key] == value)\n                ):\n                    # If the keyword argument value is one of the filtered\n                    # default values, and equals the parameter default\u2014drop it\n                    # from the `kwargs` dictionary to allow the argument\n                    # to be superseded by any applicable conditional defaults.\n                    del kwargs[key]\n                kwargs_or_defaults.setdefault(key, value)\n            condition_args, condition_kwargs = (\n                get_function_signature_applicable_args_kwargs(\n                    condition_signature, args, kwargs_or_defaults\n                )\n            )\n            if condition(*condition_args, **condition_kwargs):\n                len_args: int = len(args)\n                if len(default_args) &gt; len_args:\n                    # Extend args if there are more default args than args\n                    args = (*args, *default_args[len_args:])\n                kwargs.update(default_kwargs)\n            return args, kwargs\n\n        if iscoroutinefunction(function):\n\n            @wraps(function)\n            async def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n                \"\"\"\n                This function wraps the original and applies conditional\n                defaults\n                \"\"\"\n                args, kwargs = get_args_kwargs(*args, **kwargs)\n                # Execute the wrapped function\n                return await function(*args, **kwargs)\n\n        else:\n\n            @wraps(function)\n            def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n                \"\"\"\n                This function wraps the original and applies conditional\n                defaults\n                \"\"\"\n                args, kwargs = get_args_kwargs(*args, **kwargs)\n                # Execute the wrapped function\n                return function(*args, **kwargs)\n\n        return wrapper\n\n    return decorating_function\n</code></pre>"},{"location":"api/environment/","title":"environment","text":""},{"location":"api/environment/#decorative_secrets.environment","title":"decorative_secrets.environment","text":""},{"location":"api/environment/#decorative_secrets.environment.ApplyEnvironmentArgumentsOptions","title":"ApplyEnvironmentArgumentsOptions  <code>dataclass</code>","text":"<p>This class contains options governing the behavior of the apply_environment_arguments  decorator.</p> <p>Attributes:</p> <ul> <li> <code>env</code>               (<code>collections.abc.Mapping[str, str]</code>)           \u2013            <p>If provided, this dictionary of environment variables will be used in lieu of <code>os.environ</code> when retrieving environment variable values.</p> </li> </ul> Source code in <code>src/decorative_secrets/environment.py</code> <pre><code>@dataclass(frozen=True)\nclass ApplyEnvironmentArgumentsOptions:\n    \"\"\"\n    This class contains options governing the behavior of the\n    [apply_environment_arguments\n    ](./#decorative_secrets.environment.apply_environment_arguments) decorator.\n\n    Attributes:\n        env: If provided, this dictionary of environment variables will be\n            used in lieu of `os.environ` when retrieving environment variable\n            values.\n    \"\"\"\n\n    env: Mapping[str, str] = field(default_factory=lambda: os.environ)\n</code></pre>"},{"location":"api/environment/#decorative_secrets.environment.apply_environment_arguments","title":"apply_environment_arguments","text":"<pre><code>apply_environment_arguments(\n    *args: decorative_secrets.environment.ApplyEnvironmentArgumentsOptions,\n    **kwargs: str\n) -&gt; collections.abc.Callable\n</code></pre> <p>This decorator maps parameter names to environment variables. Each key represents the name of a parameter in the decorated function which accepts an explicit input, and the corresponding mapped value is a parameter name accepting an environment variable from which to obtain the value when no value is explicitly provided.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>               (<code>decorative_secrets.environment.ApplyEnvironmentArgumentsOptions</code>, default:                   <code>()</code> )           \u2013            <p>An optional ApplyEnvironmentArgumentsOptions  instance governing the behavior of this decorator. If not provided, a default instance of ApplyEnvironmentArgumentsOptions() . If multiple instances are provided, only the first will be used.</p> </li> <li> <code>**kwargs</code>               (<code>str</code>, default:                   <code>{}</code> )           \u2013            <p>A mapping of static parameter names to the parameter names of arguments accepting environment variable names from which to retrieve the value when the key argument is not explicitly provided.</p> </li> </ul> Example <pre><code>from functools import (\n    cache,\n)\nfrom decorative_secrets.environment import (\n    apply_environment_arguments,\n)\nfrom my_client_sdk import (\n    Client,\n)\n\n\n@cache\n@apply_onepassword_arguments(\n    client_id=\"client_id_environment_variable\",\n    client_secret=\"client_secret_environment_variable\",\n)\ndef get_client(\n    client_id: str | None = None,\n    client_secret: str = None,\n    client_id_environment_variable: str | None = None,\n    client_secret_environment_variable: str | None = None,\n) -&gt; Client:\n    return Client(\n        oauth2_client_id=client_id,\n        oauth2_client_secret=client_secret,\n    )\n\n\nclient: Client = get_client(\n    client_id_environment_variable=(\"CLIENT_ID\",),\n    client_secret_environment_variable=(\"CLIENT_SECRET\",),\n)\n</code></pre> Source code in <code>src/decorative_secrets/environment.py</code> <pre><code>def apply_environment_arguments(\n    *args: ApplyEnvironmentArgumentsOptions,\n    **kwargs: str,\n) -&gt; Callable:\n    \"\"\"\n    This decorator maps parameter names to environment variables.\n    Each key represents the name of a parameter in the decorated function\n    which accepts an explicit input, and the corresponding mapped value is a\n    parameter name accepting an environment variable from which to obtain\n    the value when no value is explicitly provided.\n\n    Parameters:\n        *args: An optional [ApplyEnvironmentArgumentsOptions\n            ](./#decorative_secrets.environment.ApplyEnvironmentArgumentsOptions)\n            instance governing the behavior of this decorator. If not provided,\n            a default instance of [ApplyEnvironmentArgumentsOptions()\n            ](./#decorative_secrets.environment.ApplyEnvironmentArgumentsOptions).\n            If multiple instances are provided, only the first will be used.\n        **kwargs:\n            A mapping of static parameter names to the parameter names\n            of arguments accepting environment variable names from which to\n            retrieve the value when the key argument is not explicitly\n            provided.\n\n    Example:\n        ```python\n        from functools import (\n            cache,\n        )\n        from decorative_secrets.environment import (\n            apply_environment_arguments,\n        )\n        from my_client_sdk import (\n            Client,\n        )\n\n\n        @cache\n        @apply_onepassword_arguments(\n            client_id=\"client_id_environment_variable\",\n            client_secret=\"client_secret_environment_variable\",\n        )\n        def get_client(\n            client_id: str | None = None,\n            client_secret: str = None,\n            client_id_environment_variable: str | None = None,\n            client_secret_environment_variable: str | None = None,\n        ) -&gt; Client:\n            return Client(\n                oauth2_client_id=client_id,\n                oauth2_client_secret=client_secret,\n            )\n\n\n        client: Client = get_client(\n            client_id_environment_variable=(\"CLIENT_ID\",),\n            client_secret_environment_variable=(\"CLIENT_SECRET\",),\n        )\n        ```\n    \"\"\"\n    options: ApplyEnvironmentArgumentsOptions\n    _, options = _get_args_options(*args)\n    return apply_callback_arguments(\n        partial(_getenv, options.env),\n        partial(_async_getenv, options.env),\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/onepassword/","title":"onepassword","text":""},{"location":"api/onepassword/#decorative_secrets.onepassword","title":"decorative_secrets.onepassword","text":""},{"location":"api/onepassword/#decorative_secrets.onepassword.ApplyOnepasswordArgumentsOptions","title":"ApplyOnepasswordArgumentsOptions  <code>dataclass</code>","text":"<p>This class contains options governing the behavior of the apply_onepassword_arguments  decorator.</p> <p>Attributes:</p> <ul> <li> <code>account</code>               (<code>str | None</code>)           \u2013            <p>A 1Password account URL. For example, individuals and families will use \"my.1password.com\", while teams and businesses will use a custom subdomain. If not provided, the <code>OP_ACCOUNT</code> environment variable will be used, if set. This is only necessary when using the 1Password CLI where multiple accounts are configured, and if no token is provided or inferred from an environment variable.</p> </li> <li> <code>token</code>               (<code>str | None</code>)           \u2013            <p>A 1Password or 1Password connect service account token. If not provided, the <code>OP_SERVICE_ACCOUNT_TOKEN</code> or <code>OP_CONNECT_TOKEN</code> environment variables will be used, if set.</p> </li> <li> <code>host</code>               (<code>str | None</code>)           \u2013            <p>A 1Password Connect host URL. If not provided, the <code>OP_CONNECT_HOST</code> environment variable will be used, if set. This is required when using a self-hosted 1Password Connect server.</p> </li> </ul> Source code in <code>src/decorative_secrets/onepassword.py</code> <pre><code>@dataclass(frozen=True)\nclass ApplyOnepasswordArgumentsOptions:\n    \"\"\"\n    This class contains options governing the behavior of the\n    [apply_onepassword_arguments\n    ](./#decorative_secrets.onepassword.apply_onepassword_arguments) decorator.\n\n    Attributes:\n        account: A 1Password account URL. For example, individuals\n            and families will use \"my.1password.com\", while teams and\n            businesses will use a custom subdomain. If not provided, the\n            `OP_ACCOUNT` environment variable will be used, if set. This is\n            only necessary when using the 1Password CLI where multiple\n            accounts are configured, and if no token is provided or inferred\n            from an environment variable.\n        token: A 1Password or 1Password connect service account\n            token. If not provided, the `OP_SERVICE_ACCOUNT_TOKEN` or\n            `OP_CONNECT_TOKEN` environment variables will be used, if set.\n        host: A 1Password Connect host URL. If not\n            provided, the `OP_CONNECT_HOST` environment variable will be used,\n            if set. This is required when using a self-hosted 1Password\n            Connect server.\n    \"\"\"\n\n    account: str | None = None\n    token: str | None = None\n    host: str | None = None\n</code></pre>"},{"location":"api/onepassword/#decorative_secrets.onepassword.apply_onepassword_arguments","title":"apply_onepassword_arguments","text":"<pre><code>apply_onepassword_arguments(\n    *args: decorative_secrets.onepassword.ApplyOnepasswordArgumentsOptions,\n    **kwargs: str\n) -&gt; collections.abc.Callable\n</code></pre> <p>This decorator maps parameter names to 1Password resources. Each key represents the name of a parameter in the decorated function which accepts an explicit input, and the corresponding mapped value is a parameter name accepting a resource path with which to lookup a secret to pass to the mapped parameter in lieu of an explicitly provided argument.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>               (<code>decorative_secrets.onepassword.ApplyOnepasswordArgumentsOptions</code>, default:                   <code>()</code> )           \u2013            <p>An optional ApplyOnepasswordArgumentsOptions  instance governing the behavior of this decorator. If not provided, a default instance of ApplyOnepasswordArgumentsOptions()  will be used. If multiple instances are provided, only the first will be used.</p> </li> <li> <code>**kwargs</code>               (<code>str</code>, default:                   <code>{}</code> )           \u2013            <p>A mapping of static parameter names to the parameter names of arguments accepting 1Password resource paths from which to retrieve the value when the key argument is not explicitly provided.</p> </li> </ul> Example <pre><code>from functools import (\n    cache,\n)\nfrom decorative_secrets.onepassword import (\n    apply_onepassword_arguments,\n)\nfrom my_client_sdk import (\n    Client,\n)\n\n\n@cache\n@apply_onepassword_arguments(\n    client_id=\"client_id_onepassword\",\n    client_secret=\"client_secret_onepassword\",\n)\ndef get_client(\n    client_id: str | None = None,\n    client_secret: str = None,\n    client_id_onepassword: str | None = None,\n    client_secret_onepassword: str | None = None,\n) -&gt; Client:\n    return Client(\n        oauth2_client_id=client_id,\n        oauth2_client_secret=client_secret,\n    )\n\n\nclient: Client = get_client(\n    client_id_onepassword=(\n        \"op://Vault Name/Client ID Item Name/username\",\n    ),\n    client_secret_onepassword=(\n        \"op://Vault Name/Client Secret Item Name/credential\",\n    ),\n)\n</code></pre> Source code in <code>src/decorative_secrets/onepassword.py</code> <pre><code>def apply_onepassword_arguments(\n    *args: ApplyOnepasswordArgumentsOptions,\n    **kwargs: str,\n) -&gt; Callable:\n    \"\"\"\n    This decorator maps parameter names to 1Password resources.\n    Each key represents the name of a parameter in the decorated function\n    which accepts an explicit input, and the corresponding mapped value is a\n    parameter name accepting a resource path with which to lookup a secret\n    to pass to the mapped parameter in lieu of an explicitly provided\n    argument.\n\n    Parameters:\n        *args: An optional [ApplyOnepasswordArgumentsOptions\n            ](./#decorative_secrets.onepassword.ApplyOnepasswordArgumentsOptions)\n            instance governing the behavior of this decorator. If not provided,\n            a default instance of [ApplyOnepasswordArgumentsOptions()\n            ](./#decorative_secrets.onepassword.ApplyOnepasswordArgumentsOptions)\n            will be used. If multiple instances are provided, only the first\n            will be used.\n        **kwargs:\n            A mapping of static parameter names to the parameter names\n            of arguments accepting 1Password resource paths from which to\n            retrieve the value when the key argument is not explicitly\n            provided.\n\n    Example:\n        ```python\n        from functools import (\n            cache,\n        )\n        from decorative_secrets.onepassword import (\n            apply_onepassword_arguments,\n        )\n        from my_client_sdk import (\n            Client,\n        )\n\n\n        @cache\n        @apply_onepassword_arguments(\n            client_id=\"client_id_onepassword\",\n            client_secret=\"client_secret_onepassword\",\n        )\n        def get_client(\n            client_id: str | None = None,\n            client_secret: str = None,\n            client_id_onepassword: str | None = None,\n            client_secret_onepassword: str | None = None,\n        ) -&gt; Client:\n            return Client(\n                oauth2_client_id=client_id,\n                oauth2_client_secret=client_secret,\n            )\n\n\n        client: Client = get_client(\n            client_id_onepassword=(\n                \"op://Vault Name/Client ID Item Name/username\",\n            ),\n            client_secret_onepassword=(\n                \"op://Vault Name/Client Secret Item Name/credential\",\n            ),\n        )\n        ```\n    \"\"\"\n    options: ApplyOnepasswordArgumentsOptions\n    args, options = _get_args_options(*args)\n    read_onepassword_secret_: Callable[..., str] = read_onepassword_secret\n    async_read_onepassword_secret_: Callable[\n        [str, str | None, str | None, str | None], Coroutine[Any, Any, str]\n    ] = async_read_onepassword_secret\n    if (\n        (options.account is not None)\n        or (options.token is not None)\n        or (options.host is not None)\n    ):\n        read_onepassword_secret_ = partial(\n            read_onepassword_secret_,\n            **({\"account\": options.account} if options.account else {}),\n            **({\"token\": options.token} if options.token else {}),\n            **({\"host\": options.host} if options.host else {}),\n        )\n        async_read_onepassword_secret_ = partial(\n            async_read_onepassword_secret_,\n            **({\"account\": options.account} if options.account else {}),\n            **({\"token\": options.token} if options.token else {}),\n            **({\"host\": options.host} if options.host else {}),\n        )\n    return apply_callback_arguments(\n        read_onepassword_secret_,\n        async_read_onepassword_secret_,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/onepassword/#decorative_secrets.onepassword.which_op","title":"which_op","text":"<pre><code>which_op() -&gt; str\n</code></pre> <p>Locate the 1Password CLI executable, or attempt to install it if not found.</p> Source code in <code>src/decorative_secrets/onepassword.py</code> <pre><code>def which_op() -&gt; str:\n    \"\"\"\n    Locate the 1Password CLI executable, or attempt\n    to install it if not found.\n    \"\"\"\n    op: str = which(\"op\") or \"op\"\n    try:\n        check_output((op, \"--version\"))\n    except (CalledProcessError, FileNotFoundError):\n        _install_op()\n        op = which(\"op\") or \"op\"\n    return op\n</code></pre>"},{"location":"api/onepassword/#decorative_secrets.onepassword.iter_op_account_list","title":"iter_op_account_list","text":"<pre><code>iter_op_account_list() -&gt; collections.abc.Iterable[str]\n</code></pre> <p>Yield all 1password account names.</p> Source code in <code>src/decorative_secrets/onepassword.py</code> <pre><code>def iter_op_account_list() -&gt; Iterable[str]:\n    \"\"\"\n    Yield all 1password account names.\n    \"\"\"\n    op: str = which_op()\n    line: str\n    for line in check_output((op, \"account\", \"list\")).strip().split(\"\\n\")[1:]:\n        yield line.partition(\" \")[0]\n</code></pre>"},{"location":"api/onepassword/#decorative_secrets.onepassword.op_signin","title":"op_signin","text":"<pre><code>op_signin(account: str | None = None) -&gt; str\n</code></pre> <p>Sign in to 1Password using the CLI if not already signed in.</p> Source code in <code>src/decorative_secrets/onepassword.py</code> <pre><code>def op_signin(account: str | None = None) -&gt; str:\n    \"\"\"\n    Sign in to 1Password using the CLI if not already signed in.\n    \"\"\"\n    account = account or os.getenv(\"OP_ACCOUNT\")\n    if account:\n        return _op_signin(account)\n    op: str | None = None\n    for account in iter_op_account_list():\n        op = _op_signin(account)\n    return op or which_op()\n</code></pre>"},{"location":"api/onepassword/#decorative_secrets.onepassword.async_read_onepassword_secret","title":"async_read_onepassword_secret  <code>async</code>","text":"<pre><code>async_read_onepassword_secret(\n    resource: str,\n    account: str | None = None,\n    token: str | None = None,\n    host: str | None = None,\n) -&gt; str\n</code></pre> <p>Asynchronously read a secret from 1Password using either the <code>onepassword-sdk</code> or <code>onepasswordconnectsdk</code> libraries, or the <code>op</code> executable (1password CLI), depending on the provided arguments and environment variables.</p> <p>Parameters:</p> <ul> <li> <code>resource</code>               (<code>str</code>)           \u2013            <p>A 1Password secret resource path. For example: \"op://Vault Name/Client Secret Item Name/credential\"</p> </li> <li> <code>account</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A 1Password account URL. For example, individuals and families will use \"my.1password.com\", while teams and businesses will use a custom subdomain. This is only necessary when using the 1Password CLI where multiple accounts are configured.</p> </li> <li> <code>token</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A 1Password or 1Password connect service account token.</p> </li> <li> <code>host</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A 1Password Connect host URL. This is required when using self-hosted 1Password Connect.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The resolved secret value.</p> </li> </ul> Source code in <code>src/decorative_secrets/onepassword.py</code> <pre><code>@alru_cache(maxsize=None)\nasync def async_read_onepassword_secret(\n    resource: str,\n    account: str | None = None,\n    token: str | None = None,\n    host: str | None = None,\n) -&gt; str:\n    \"\"\"\n    Asynchronously read a secret from 1Password using either the\n    `onepassword-sdk` or `onepasswordconnectsdk` libraries, or the `op`\n    executable (1password CLI), depending on the provided arguments and\n    environment variables.\n\n    Parameters:\n        resource: A 1Password secret resource path. For example:\n            \"op://Vault Name/Client Secret Item Name/credential\"\n        account: A 1Password account URL. For example, individuals and families\n            will use \"my.1password.com\", while teams and businesses will use\n            a custom subdomain. This is only necessary when using\n            the 1Password CLI where multiple accounts are configured.\n        token: A 1Password or 1Password connect service account token.\n        host: A 1Password Connect host URL. This is required when using\n            self-hosted 1Password Connect.\n\n    Returns:\n        The resolved secret value.\n    \"\"\"\n    account, token, host = _resolve_auth_arguments(account, token, host)\n    if token:\n        if host:\n            return await _async_resolve_connect_resource(token, host, resource)\n        return await _async_resolve_resource(token, resource)\n    op: str | None = None\n    with suppress(FileNotFoundError, CalledProcessError):\n        op = op_signin(account)\n    if not op:\n        op = which_op() or \"op\"\n    return check_output(\n        (op, \"read\")\n        + ((\"--account\", account) if account else ())\n        + ((\"--session\", token) if token else ())\n        + (resource,)\n    )\n</code></pre>"},{"location":"api/onepassword/#decorative_secrets.onepassword.get_onepassword_secret","title":"get_onepassword_secret","text":"<pre><code>get_onepassword_secret(\n    resource: str,\n    account: str | None = None,\n    token: str | None = None,\n    host: str | None = None,\n) -&gt; str\n</code></pre> <p>Read a secret from 1Password using either the <code>onepassword-sdk</code> or <code>onepasswordconnectsdk</code> libraries, or the <code>op</code> executable (1password CLI), depending on the provided arguments and environment variables.</p> <p>Parameters:</p> <ul> <li> <code>resource</code>               (<code>str</code>)           \u2013            <p>A 1Password secret resource path. For example: \"op://Vault Name/Client Secret Item Name/credential\"</p> </li> <li> <code>account</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A 1Password account URL. For example, individuals and families will use \"my.1password.com\", while teams and businesses will use a custom subdomain. This is only necessary when using the 1Password CLI where multiple accounts are configured.</p> </li> <li> <code>token</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A 1Password or 1Password connect service account token.</p> </li> <li> <code>host</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A 1Password Connect host URL. This is required when using self-hosted 1Password Connect.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The resolved secret value.</p> </li> </ul> Source code in <code>src/decorative_secrets/onepassword.py</code> <pre><code>def get_onepassword_secret(\n    resource: str,\n    account: str | None = None,\n    token: str | None = None,\n    host: str | None = None,\n) -&gt; str:\n    \"\"\"\n    Read a secret from 1Password using either the `onepassword-sdk` or\n    `onepasswordconnectsdk` libraries, or the `op` executable (1password CLI),\n    depending on the provided arguments and environment variables.\n\n    Parameters:\n        resource: A 1Password secret resource path. For example:\n            \"op://Vault Name/Client Secret Item Name/credential\"\n        account: A 1Password account URL. For example, individuals and families\n            will use \"my.1password.com\", while teams and businesses will use\n            a custom subdomain. This is only necessary when using\n            the 1Password CLI where multiple accounts are configured.\n        token: A 1Password or 1Password connect service account token.\n        host: A 1Password Connect host URL. This is required when using\n            self-hosted 1Password Connect.\n\n    Returns:\n        The resolved secret value.\n    \"\"\"\n    return _read_onepassword_secret(\n        resource, account=account, token=token, host=host, **os.environ\n    )\n</code></pre>"},{"location":"api/onepassword/#decorative_secrets.onepassword.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Run a command: -   install: Install the Databricks CLI if not already installed -   get: Get a secret from Databricks and print it to stdout</p> Source code in <code>src/decorative_secrets/onepassword.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Run a command:\n    -   install: Install the Databricks CLI if not already installed\n    -   get: Get a secret from Databricks and print it to stdout\n    \"\"\"\n    command = _get_command()\n    if command in (\"--help\", \"-h\"):\n        _print_help()\n        return\n    parser: argparse.ArgumentParser\n    if command == \"install\":\n        parser = argparse.ArgumentParser(\n            prog=\"decorative-secrets onepassword install\",\n            description=\"Install the 1Password CLI\",\n        )\n        parser.parse_args()\n        _install_op()\n    elif command == \"get\":\n        parser = argparse.ArgumentParser(\n            prog=\"decorative-secrets onepassword get\",\n            description=\"Get a secret from 1Password\",\n        )\n        parser.add_argument(\n            \"reference\",\n            type=str,\n        )\n        parser.add_argument(\n            \"--account\",\n            default=None,\n            type=str,\n            help=\"Which 1Password account to use\",\n        )\n        parser.add_argument(\n            \"-t\",\n            \"--token\",\n            default=None,\n            type=str,\n            help=\"A 1Password Service Account Token\",\n        )\n        parser.add_argument(\n            \"--host\",\n            default=None,\n            type=str,\n            help=\"A 1Password Connect Host URL\",\n        )\n        namespace: argparse.Namespace = parser.parse_args()\n        print(  # noqa: T201\n            read_onepassword_secret(\n                namespace.reference,\n                host=namespace.host,\n                account=namespace.account,\n                token=namespace.token,\n            )\n        )\n</code></pre>"},{"location":"api/utilities/","title":"Utilities","text":""},{"location":"api/utilities/#decorative_secrets.utilities","title":"decorative_secrets.utilities","text":""},{"location":"api/utilities/#decorative_secrets.utilities.iscoroutinefunction","title":"iscoroutinefunction","text":"<pre><code>iscoroutinefunction(function: typing.Any) -&gt; bool\n</code></pre> <p>An adaptation of <code>asyncio.iscoroutinefunction</code></p> Source code in <code>src/decorative_secrets/utilities.py</code> <pre><code>def iscoroutinefunction(function: Any) -&gt; bool:\n    \"\"\"\n    An adaptation of `asyncio.iscoroutinefunction`\n    \"\"\"\n    if isinstance(function, partial):\n        return iscoroutinefunction(function.func)\n    return (\n        inspect.iscoroutinefunction(function)\n        or type(getattr(function, \"_is_coroutine\", None)) is object\n    )\n</code></pre>"},{"location":"api/utilities/#decorative_secrets.utilities.as_tuple","title":"as_tuple","text":"<pre><code>as_tuple(\n    function: collections.abc.Callable[\n        ...,\n        collections.abc.Iterable[typing.Any]\n        | collections.abc.Awaitable[\n            collections.abc.Iterable[typing.Any]\n        ],\n    ],\n) -&gt; collections.abc.Callable[..., typing.Any]\n</code></pre> <p>This is a decorator which will return an iterable as a tuple.</p> <p>Examples:</p> <pre><code>from decorative_secrets.utilities import as_tuple\n\n\n@as_tuple\ndef get_numbers() -&gt; Iterable[int]:\n    yield 1\n    yield 2\n    yield 3\n\n\nassert get_numbers() == (1, 2, 3)\n</code></pre> Source code in <code>src/decorative_secrets/utilities.py</code> <pre><code>def as_tuple(\n    function: Callable[..., Iterable[Any] | Awaitable[Iterable[Any]]],\n) -&gt; Callable[..., Any]:\n    \"\"\"\n    This is a decorator which will return an iterable as a tuple.\n\n    Examples:\n        ```python\n        from decorative_secrets.utilities import as_tuple\n\n\n        @as_tuple\n        def get_numbers() -&gt; Iterable[int]:\n            yield 1\n            yield 2\n            yield 3\n\n\n        assert get_numbers() == (1, 2, 3)\n        ```\n    \"\"\"\n    if iscoroutinefunction(function):\n\n        @wraps(function)\n        async def wrapper(*args: Any, **kwargs: Any) -&gt; tuple[Any, ...]:\n            return tuple(  # --\n                await function(*args, **kwargs) or ()  # type: ignore[misc]\n            )\n\n    else:\n\n        @wraps(function)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; tuple[Any, ...]:\n            return tuple(\n                function(*args, **kwargs) or ()  # type: ignore[arg-type]\n            )\n\n    return wrapper\n</code></pre>"},{"location":"api/utilities/#decorative_secrets.utilities.as_str","title":"as_str","text":"<pre><code>as_str(\n    function: None = None, separator: str = \"\"\n) -&gt; collections.abc.Callable[\n    ..., collections.abc.Callable[..., str]\n]\n</code></pre><pre><code>as_str(\n    function: collections.abc.Callable[\n        ..., collections.abc.Iterable[str]\n    ] = ...,\n    separator: str = \"\",\n) -&gt; collections.abc.Callable[..., str]\n</code></pre> <pre><code>as_str(\n    function: (\n        collections.abc.Callable[\n            ..., collections.abc.Iterable[str]\n        ]\n        | collections.abc.Awaitable[\n            collections.abc.Iterable[typing.Any]\n        ]\n        | None\n    ) = None,\n    separator: str = \"\",\n) -&gt; (\n    collections.abc.Callable[\n        ..., collections.abc.Callable[..., str]\n    ]\n    | collections.abc.Callable[..., str]\n)\n</code></pre> <pre><code>This decorator causes a function yielding an iterable of strings to\nreturn a single string with the elements joined by the specified\n`separator`.\n\nParameters:\n    function: The function to decorate. If `None`, a decorating\n        function is returned.\n    separator: The string used to join the iterable elements.\n\nReturns:\n    A decorator which joins the iterable elements into a single string.\n\nExamples:\n    ```python\n    from decorative_secrets.utilities import as_str\n\n\n    @as_str(separator=\", \")\n    def get_fruits() -&gt; Iterable[str]:\n        yield \"apple\"\n        yield \"banana\"\n        yield \"cherry\"\n\n\n    assert get_fruits() == \"apple, banana, cherry\"\n    ```\n\n    ```python\n    from decorative_secrets.utilities import as_str\n\n\n    @as_str\n    def get_fruits() -&gt; Iterable[str]:\n        yield \"apple\n</code></pre> <p>\"             yield \"banana \"             yield \"cherry\"</p> <pre><code>    assert get_fruits() == \"apple\n</code></pre> <p>banana cherry\"         ```</p> Source code in <code>src/decorative_secrets/utilities.py</code> <pre><code>def as_str(\n    function: Callable[..., Iterable[str]]\n    | Awaitable[Iterable[Any]]\n    | None = None,\n    separator: str = \"\",\n) -&gt; Callable[..., Callable[..., str]] | Callable[..., str]:\n    \"\"\"\n    This decorator causes a function yielding an iterable of strings to\n    return a single string with the elements joined by the specified\n    `separator`.\n\n    Parameters:\n        function: The function to decorate. If `None`, a decorating\n            function is returned.\n        separator: The string used to join the iterable elements.\n\n    Returns:\n        A decorator which joins the iterable elements into a single string.\n\n    Examples:\n        ```python\n        from decorative_secrets.utilities import as_str\n\n\n        @as_str(separator=\", \")\n        def get_fruits() -&gt; Iterable[str]:\n            yield \"apple\"\n            yield \"banana\"\n            yield \"cherry\"\n\n\n        assert get_fruits() == \"apple, banana, cherry\"\n        ```\n\n        ```python\n        from decorative_secrets.utilities import as_str\n\n\n        @as_str\n        def get_fruits() -&gt; Iterable[str]:\n            yield \"apple\\n\"\n            yield \"banana\\n\"\n            yield \"cherry\"\n\n\n        assert get_fruits() == \"apple\\nbanana\\ncherry\"\n        ```\n    \"\"\"\n\n    def decorating_function(\n        user_function: Callable[..., Iterable[str]],\n    ) -&gt; Callable[..., Any]:\n        if iscoroutinefunction(user_function):\n\n            @wraps(user_function)\n            async def wrapper(*args: Any, **kwargs: Any) -&gt; str:\n                return separator.join(\n                    await user_function(  # type: ignore[misc]\n                        *args, **kwargs\n                    )\n                    or ()\n                )\n\n        else:\n\n            @wraps(user_function)\n            def wrapper(*args: Any, **kwargs: Any) -&gt; str:\n                return separator.join(user_function(*args, **kwargs) or ())\n\n        return wrapper\n\n    if function is None:\n        return decorating_function\n    return decorating_function(function)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/utilities/#decorative_secrets.utilities.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    function: collections.abc.Callable[\n        ...,\n        collections.abc.Iterable[\n            tuple[typing.Any, typing.Any]\n        ]\n        | collections.abc.Awaitable[\n            collections.abc.Iterable[\n                tuple[typing.Any, typing.Any]\n            ]\n        ],\n    ],\n) -&gt; collections.abc.Callable[..., typing.Any]\n</code></pre> <p>This is a decorator which will return an iterable of key/value pairs as a dictionary.</p> <p>Examples:</p> <pre><code>from decorative_secrets.utilities import as_dict\n\n\n@as_dict\ndef get_settings() -&gt; Iterable[tuple[str, Any]]:\n    yield (\"host\", \"localhost\")\n    yield (\"port\", 8080)\n    yield (\"debug\", True)\n\n\nassert get_settings() == (\n    {\"host\": \"localhost\", \"port\": 8080, \"debug\": True}\n)\n</code></pre> Source code in <code>src/decorative_secrets/utilities.py</code> <pre><code>def as_dict(\n    function: Callable[\n        ..., Iterable[tuple[Any, Any]] | Awaitable[Iterable[tuple[Any, Any]]]\n    ],\n) -&gt; Callable[..., Any]:\n    \"\"\"\n    This is a decorator which will return an iterable of key/value pairs\n    as a dictionary.\n\n    Examples:\n        ```python\n        from decorative_secrets.utilities import as_dict\n\n\n        @as_dict\n        def get_settings() -&gt; Iterable[tuple[str, Any]]:\n            yield (\"host\", \"localhost\")\n            yield (\"port\", 8080)\n            yield (\"debug\", True)\n\n\n        assert get_settings() == (\n            {\"host\": \"localhost\", \"port\": 8080, \"debug\": True}\n        )\n        ```\n    \"\"\"\n\n    if iscoroutinefunction(function):\n\n        @wraps(function)\n        async def wrapper(*args: Any, **kwargs: Any) -&gt; dict[Any, Any]:\n            return dict(\n                await function(*args, **kwargs) or ()  # type: ignore[misc]\n            )\n\n    else:\n\n        @wraps(function)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; dict[Any, Any]:\n            return dict(\n                function(*args, **kwargs) or ()  # type: ignore[arg-type]\n            )\n\n    return wrapper\n</code></pre>"},{"location":"api/utilities/#decorative_secrets.utilities.as_iter","title":"as_iter","text":"<pre><code>as_iter(\n    function: collections.abc.Callable[\n        ..., collections.abc.Iterable[typing.Any]\n    ],\n) -&gt; collections.abc.Callable[..., typing.Any]\n</code></pre> <p>This is a decorator which will return an iterator for a function yielding an iterable.</p> <p>Examples:</p> <pre><code>from decorative_secrets.utilities import as_iter\nfrom collections.abc import Iterator\n\n\n@as_iter\ndef get_settings() -&gt; Iterable[tuple[str, Any]]:\n    yield (\"host\", \"localhost\")\n    yield (\"port\", 8080)\n    yield (\"debug\", True)\n\n\nassert issubclass(get_settings(), Iterator)\n</code></pre> Source code in <code>src/decorative_secrets/utilities.py</code> <pre><code>def as_iter(\n    function: Callable[..., Iterable[Any]],\n) -&gt; Callable[..., Any]:\n    \"\"\"\n    This is a decorator which will return an iterator for a function\n    yielding an iterable.\n\n    Examples:\n        ```python\n        from decorative_secrets.utilities import as_iter\n        from collections.abc import Iterator\n\n\n        @as_iter\n        def get_settings() -&gt; Iterable[tuple[str, Any]]:\n            yield (\"host\", \"localhost\")\n            yield (\"port\", 8080)\n            yield (\"debug\", True)\n\n\n        assert issubclass(get_settings(), Iterator)\n        ```\n    \"\"\"\n\n    if iscoroutinefunction(function):\n\n        @wraps(function)\n        async def wrapper(*args: Any, **kwargs: Any) -&gt; Iterator[Any]:\n            return iter(\n                await function(*args, **kwargs) or ()  # type: ignore[misc]\n            )\n\n    else:\n\n        @wraps(function)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Iterator[Any]:\n            return iter(function(*args, **kwargs) or ())\n\n    return wrapper\n</code></pre>"},{"location":"api/utilities/#decorative_secrets.utilities.warn_retry_hook","title":"warn_retry_hook","text":"<pre><code>warn_retry_hook(\n    error: Exception,\n    attempt_number: int,\n    *args: typing.Any,\n    **kwargs: typing.Any\n) -&gt; bool\n</code></pre> <p>This is a retry hook which will issue a warning and retry number whenever an error occurs.</p> Source code in <code>src/decorative_secrets/utilities.py</code> <pre><code>def warn_retry_hook(\n    error: Exception,\n    attempt_number: int,\n    *args: Any,  # noqa: ARG001\n    **kwargs: Any,  # noqa: ARG001\n) -&gt; bool:\n    \"\"\"\n    This is a retry hook which will issue a warning and retry number\n    whenever an error occurs.\n    \"\"\"\n    message: str = f\"Attempt # {attempt_number} failed with error: {error}\"\n    warn(\n        message,\n        stacklevel=2,\n    )\n    return True\n</code></pre>"},{"location":"api/utilities/#decorative_secrets.utilities.create_log_warning_retry_hook","title":"create_log_warning_retry_hook","text":"<pre><code>create_log_warning_retry_hook(\n    logger: (\n        logging.Logger\n        | collections.abc.Callable[[], logging.Logger]\n    ),\n) -&gt; decorative_secrets.utilities.RetryHook\n</code></pre> <p>This factory creates a retry hook which logs warning using the provided logger.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>logging.Logger | collections.abc.Callable[[], logging.Logger]</code>)           \u2013            <p>The logger to use for logging warnings, or a callable which</p> </li> </ul> Source code in <code>src/decorative_secrets/utilities.py</code> <pre><code>def create_log_warning_retry_hook(\n    logger: logging.Logger | Callable[[], logging.Logger],\n) -&gt; RetryHook:\n    \"\"\"\n    This factory creates a retry hook which logs warning using the provided\n    logger.\n\n    Parameters:\n        logger: The logger to use for logging warnings, or a callable which\n        returns a logger.\n    \"\"\"\n    if not isinstance(logger, logging.Logger) and callable(logger):\n        logger = logger()\n    if not isinstance(logger, logging.Logger):\n        raise TypeError(logger)\n\n    def retry_hook(\n        error: Exception,\n        attempt_number: int,\n        *args: Any,  # noqa: ARG001\n        **kwargs: Any,  # noqa: ARG001\n    ) -&gt; bool:\n        logger.warning(\n            \"Attempt # %d failed with error: %s\",\n            attempt_number,\n            str(error),\n            stacklevel=2,\n        )\n        return True\n\n    return retry_hook\n</code></pre>"},{"location":"api/utilities/#decorative_secrets.utilities.create_async_log_warning_retry_hook","title":"create_async_log_warning_retry_hook","text":"<pre><code>create_async_log_warning_retry_hook(\n    logger: logging.Logger,\n) -&gt; decorative_secrets.utilities.AsyncRetryHook\n</code></pre> <p>This factory creates an async retry hook which logs warning using the provided logger.</p> <p>!!! Note     Please make sure to use a non-blocking logger     .</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>logging.Logger</code>)           \u2013            <p>The logger to use for logging warnings.</p> </li> </ul> Source code in <code>src/decorative_secrets/utilities.py</code> <pre><code>def create_async_log_warning_retry_hook(\n    logger: logging.Logger,\n) -&gt; AsyncRetryHook:\n    \"\"\"\n    This factory creates an async retry hook which logs warning using the\n    provided logger.\n\n    !!! Note\n        Please make sure to use a [non-blocking logger\n        ](https://docs.python.org/3/howto/logging-cookbook.html#dealing-with-handlers-that-block).\n\n    Parameters:\n        logger: The logger to use for logging warnings.\n    \"\"\"\n\n    async def retry_hook(\n        error: Exception,\n        attempt_number: int,\n        *args: Any,  # noqa: ARG001\n        **kwargs: Any,  # noqa: ARG001\n    ) -&gt; bool:\n        logger.warning(\n            \"Attempt # %d failed with error: %s\",\n            attempt_number,\n            str(error),\n            stacklevel=2,\n        )\n        return True\n\n    return retry_hook\n</code></pre>"},{"location":"api/utilities/#decorative_secrets.utilities.retry","title":"retry","text":"<pre><code>retry(\n    errors: tuple[type[Exception], ...],\n    retry_hook: (\n        decorative_secrets.utilities.RetryHook\n        | decorative_secrets.utilities.AsyncRetryHook\n    ) = decorative_secrets.utilities._default_retry_hook,\n    number_of_attempts: int = 2,\n) -&gt; collections.abc.Callable\n</code></pre> <p>This is a decorator which will retry a function a specified number of times, with exponential backoff, if it raises one of the specified errors types.</p> <p>Parameters:</p> <ul> <li> <code>errors</code>               (<code>tuple[type[Exception], ...]</code>)           \u2013            <p>A tuple of exception types which should trigger a retry.</p> </li> <li> <code>retry_hook</code>               (<code>decorative_secrets.utilities.RetryHook | decorative_secrets.utilities.AsyncRetryHook</code>, default:                   <code>decorative_secrets.utilities._default_retry_hook</code> )           \u2013            <p>A function which is called with the exception instance (optionally) and an attempt number when an error occurs. If this function returns <code>False</code>, the exception is re-raised and no further retries are attempted.</p> </li> <li> <code>number_of_attempts</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The total number of attempts to make, including the initial attempt.</p> </li> </ul> Source code in <code>src/decorative_secrets/utilities.py</code> <pre><code>def retry(  # noqa: C901\n    errors: tuple[type[Exception], ...],\n    retry_hook: RetryHook | AsyncRetryHook = _default_retry_hook,\n    number_of_attempts: int = 2,\n) -&gt; Callable:\n    \"\"\"\n    This is a decorator which will retry a function a specified\n    number of times, with exponential backoff, if it raises one of the\n    specified errors types.\n\n    Parameters:\n        errors: A tuple of exception types which should trigger a retry.\n        retry_hook: A function which is called with the exception instance\n            (optionally) and an attempt number when an error occurs. If this\n            function returns `False`, the exception is re-raised and no further\n            retries are attempted.\n        number_of_attempts: The total number of attempts to make, including\n            the initial attempt.\n    \"\"\"\n\n    def decorating_function(function: Callable) -&gt; Callable:\n        attempt_number: int = 1\n        if iscoroutinefunction(function):\n\n            @wraps(function)\n            async def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n                nonlocal attempt_number\n                if (number_of_attempts - attempt_number) &gt; 0:\n                    # If `number_of_attempts` is greater than `attempt_number`,\n                    # we have remaining attempts to try, so catch errors.\n                    try:\n                        return await function(*args, **kwargs)\n                    except errors as error:\n                        if not (\n                            (\n                                await retry_hook(  # type: ignore[misc]\n                                    error, attempt_number\n                                )\n                                if len(\n                                    inspect.signature(retry_hook).parameters\n                                )\n                                &gt; 1\n                                else await retry_hook(  # type: ignore[misc]\n                                    error\n                                )\n                            )\n                            if iscoroutinefunction(retry_hook)\n                            else (\n                                retry_hook(error, attempt_number)\n                                if len(\n                                    inspect.signature(retry_hook).parameters\n                                )\n                                &gt; 1\n                                else retry_hook(error)\n                            )\n                        ):\n                            raise\n                        await asyncio.sleep(2**attempt_number)\n                        attempt_number += 1\n                        return await wrapper(*args, **kwargs)\n                # This is our last attempt, so just call the function.\n                return await function(*args, **kwargs)\n\n        else:\n\n            @wraps(function)\n            def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n                nonlocal attempt_number\n                if (number_of_attempts - attempt_number) &gt; 0:\n                    try:\n                        return function(*args, **kwargs)\n                    except errors as error:\n                        if not (\n                            retry_hook(error, attempt_number)\n                            if len(inspect.signature(retry_hook).parameters)\n                            &gt; 1\n                            else retry_hook(error)\n                        ):\n                            raise\n                        sleep(2**attempt_number)\n                        attempt_number += 1\n                        return wrapper(*args, **kwargs)\n                return function(*args, **kwargs)\n\n        return wrapper\n\n    return decorating_function\n</code></pre>"},{"location":"api/utilities/#decorative_secrets.utilities.get_exception_text","title":"get_exception_text","text":"<pre><code>get_exception_text() -&gt; str\n</code></pre> <p>When called within an exception, this function returns a text representation of the error matching what is found in <code>traceback.print_exception</code>, but is returned as a string value rather than printing.</p> Source code in <code>src/decorative_secrets/utilities.py</code> <pre><code>def get_exception_text() -&gt; str:\n    \"\"\"\n    When called within an exception, this function returns a text\n    representation of the error matching what is found in\n    `traceback.print_exception`, but is returned as a string value rather than\n    printing.\n    \"\"\"\n    return \"\".join(format_exception(*sys.exc_info()))\n</code></pre>"}]}